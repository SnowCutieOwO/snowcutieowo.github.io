import{_ as l,C as e,c as t,o as d,an as n,G as r}from"./chunks/framework.FiaHILad.js";const q=JSON.parse('{"title":"SSBProxyBridge","description":"","frontmatter":{"breadcrumbs":[{"title":"Continue Project","link":"/SuperiorSkyblock2"},{"title":"SSBProxyBridge","link":"/SuperiorSkyblock2/overview.addons.ssbproxybridge"}]},"headers":[],"relativePath":"SuperiorSkyblock2/overview.addons.ssbproxybridge.md","filePath":"SuperiorSkyblock2/overview.addons.ssbproxybridge.md"}'),h={name:"SuperiorSkyblock2/overview.addons.ssbproxybridge.md"};function s(p,a,c,b,u,k){const o=e("NolebaseGitContributors"),i=e("NolebaseGitChangelog");return d(),t("div",null,[a[0]||(a[0]=n('<h1 id="ssbproxybridge" tabindex="-1">SSBProxyBridge <a class="header-anchor" href="#ssbproxybridge" aria-label="Permalink to &quot;SSBProxyBridge&quot;">​</a></h1><p>为 SuperiorSkyBlock2 添加多服同步</p><p>这是一个添加了群组（如 Velocity 或 BungeeCord）兼容的附属。这个模块可以用于单个子服无法负荷的群组服中。</p><h2 id="常见问题" tabindex="-1">常见问题 <a class="header-anchor" href="#常见问题" aria-label="Permalink to &quot;常见问题&quot;">​</a></h2><h3 id="它是免费的吗" tabindex="-1">它是免费的吗？ <a class="header-anchor" href="#它是免费的吗" aria-label="Permalink to &quot;它是免费的吗？&quot;">​</a></h3><p>抱歉，不是。这个附属是付费的，且按月订阅，每个月大约 30$。原因是这个模块只针对大型服务器（所以有足够的收入用于购买本插件），且开发团队在这里投入了很多精力。插件不依赖 SuperiorSkyblock2，另外购买用户也会获得付费支持（帮助搭建、漏洞修复、提供问答等等）。</p><h3 id="世界是否可以被保存至服务器中" tabindex="-1">世界是否可以被保存至服务器中？ <a class="header-anchor" href="#世界是否可以被保存至服务器中" aria-label="Permalink to &quot;世界是否可以被保存至服务器中？&quot;">​</a></h3><p>抱歉，不行。岛屿不可以被序列化并存入数据库中，因为附属无法修改世界处理的方式。</p><h3 id="附属是否能实现-一岛一服" tabindex="-1">附属是否能实现“一岛一服”？ <a class="header-anchor" href="#附属是否能实现-一岛一服" aria-label="Permalink to &quot;附属是否能实现“一岛一服”？&quot;">​</a></h3><p>附属只会将玩家引流至现有的服务器，并确保他们均匀分散。</p><h3 id="附属是否支持-slimeworldmanager-或其他相似的世界管理插件" tabindex="-1">附属是否支持 SlimeWorldManager 或其他相似的世界管理插件？ <a class="header-anchor" href="#附属是否支持-slimeworldmanager-或其他相似的世界管理插件" aria-label="Permalink to &quot;附属是否支持 SlimeWorldManager 或其他相似的世界管理插件？&quot;">​</a></h3><p>是的，附属不会破坏现有的世界管理模块。</p><h3 id="是否能随时间添加更多服务器" tabindex="-1">是否能随时间添加更多服务器？ <a class="header-anchor" href="#是否能随时间添加更多服务器" aria-label="Permalink to &quot;是否能随时间添加更多服务器？&quot;">​</a></h3><p>是的，你可以添加新的服务器，这样玩家就会被引入其中。</p><p>但是，移除服务器可能会导致岛屿无法加载，且玩家无法传送。</p><h3 id="玩家是否可以访问其他子服的玩家并与之交互" tabindex="-1">玩家是否可以访问其他子服的玩家并与之交互？ <a class="header-anchor" href="#玩家是否可以访问其他子服的玩家并与之交互" aria-label="Permalink to &quot;玩家是否可以访问其他子服的玩家并与之交互？&quot;">​</a></h3><p>当然！模块旨在不妨碍玩家正常的游玩体验。</p><h3 id="服务器关闭时会发生什么" tabindex="-1">服务器关闭时会发生什么？ <a class="header-anchor" href="#服务器关闭时会发生什么" aria-label="Permalink to &quot;服务器关闭时会发生什么？&quot;">​</a></h3><p>当服务器出现问题时，玩家会转回大厅服，他们将无法回到自己的岛屿。这听起来可能有点问题，但这就像服务器维护——等维护结束自然可以进入游玩。这种情况不应常出现，空岛实例应当与整个群组服持续存在。但好处是数据不会损坏——如果服务器关闭不是崩溃导致的，那么数据不会受到影响。</p><h2 id="内部" tabindex="-1">内部 <a class="header-anchor" href="#内部" aria-label="Permalink to &quot;内部&quot;">​</a></h2><p>在我们开始讲解模块内部机制之前，我们需要先了解 SuperiorSkyBlock2 保存数据的方式。每个对象都可以被保存至数据库（岛屿、玩家等）都有一个对应类用于处理数据库交互，且对象之间独立。这个类就是数据库与对象间的桥梁，即“<a href="https://github.com/BG-Software-LLC/SuperiorSkyblock2/blob/master/API/src/main/java/com/bgsoftware/superiorskyblock/api/data/DatabaseBridge.java" target="_blank" rel="noreferrer">DatabaseBridge</a>”。</p><p>在玩家作出需要交互数据库的改动时，对象先调用数据库桥的方法，之后再与数据库异步交互。这可以让插件不必担心数据库的实现，即与任意种类的数据库兼容——SQL、MongoDB 以及能实现数据库桥所需方法的其他数据库。</p><p>你可能会问自己，为何这么重要？这就是奇妙的地方。新附属会处理插件中的对象与数据库桥——因此，它会将数据导向别处而非存入数据库进行处理。因为这个过程完全异步，所以无需担心性能问题。</p><p>既然我已经解释了附属的目的，我们需要理解并处理我们接下来碰到的一系列问题：</p><ul><li>负载平衡；我们需要将岛屿分散在各个子服，而不是让它们全部堆积在同一服务器。</li><li>附属兼容；例如 SlimeWorldManager 世界等。我们仍然需要支持其他模块（除了一并修改数据库桥的那些）。</li><li>数据同步；我们需要邀请、聊天消息能在服务器之间显示。</li><li>支持多群组；现在单个群组可能不足以支撑足够的玩家，多群组组成的网络才能胜任。</li><li>性能；最重要的就是让服务器保持在性能最佳状态。否则，附属的意义何在？</li></ul><p>我将会在之后的篇幅中详细解释这些问题，并给出相应的解决方案。</p><h3 id="负载平衡" tabindex="-1">负载平衡 <a class="header-anchor" href="#负载平衡" aria-label="Permalink to &quot;负载平衡&quot;">​</a></h3><p>为了让服务器能有较好的性能表现，这个附属会将玩家分散至子服。为了实现这个功能，它在玩家一侧表现得像负载均衡器，寻找条件最优的服务器并将玩家的空岛创建在此处。</p><p>在空岛实例中的附属还会有一些额外效果——它也是一个群组插件，能够查询服务器。群组端会试图搜寻每个服务器的岛屿，并会记录其活跃状态。总而言之，拥有更多活跃空岛的服务器更有可能卡顿。因此，创建岛屿时，附属会寻找活跃岛屿最少的服务器，并与服务器上的插件沟通从而创建岛屿。之后，玩家就会被传送至对应的服务器。</p><h3 id="附属兼容" tabindex="-1">附属兼容 <a class="header-anchor" href="#附属兼容" aria-label="Permalink to &quot;附属兼容&quot;">​</a></h3><p>正如上文所述，附属只会修改插件的数据库层，并将原本转入数据库的数据转至其他远程服务器。这使得修改其他内容的附属不会受该附属的影响。只要你保持空岛实例的配置与附属同步，所有功能都会如常运转。</p><h3 id="数据同步" tabindex="-1">数据同步 <a class="header-anchor" href="#数据同步" aria-label="Permalink to &quot;数据同步&quot;">​</a></h3><p>本附属的最大功能就是在多个子服间同步数据。为了实现这个功能，服务器必须先与其他子服沟通，才可在其间同步数据。问题是“这如何实现”，那么在本段中我们就会着重讲述。</p><p>在我们详细了解之前，我们首先需要考虑一些事：</p><ul><li>岛屿可以被任何服务器修改，因此改动应当被同步（多个对同一岛屿的改动应当包含所有改动）</li><li>我们需要一个能让空岛实例在服务器间相互沟通的组件（信息队列/中断器）</li><li>我们需要一个处理数据保存的组件（数据库）</li></ul><h4 id="消息队列-代理" tabindex="-1">消息队列/代理 <a class="header-anchor" href="#消息队列-代理" aria-label="Permalink to &quot;消息队列/代理&quot;">​</a></h4><p>这是一种设计模式，用于处理服务之间的异步沟通。例如，当一个服务想要通知其他服务事件时，它会向第三方组件发送消息，之后其他服务即可从该组件读取消息，而非直接与它们沟通。这样的设计会破坏服务之间的硬链接，并允许多个服务器相互沟通——这个组件就称为消息代理（Message Broker）。消息代理以一个队列存储它收到的信息（首条收到的消息即为首条读取的消息），服务可订阅消息代理并读取它收到的消息。因为服务之间没有直接连接，服务只能在它们被允许的时候读取来自代理的消息，这有助于提升性能。</p><p>在我们的示例中，空岛实例会让其他实例收到某些事件——岛屿创建、岛屿数据解读等。之后，其他空岛示例会监听消息并更新数据，同时完成其他必要的操作。这样的一个例子就是创建岛屿。</p><h4 id="数据库" tabindex="-1">数据库 <a class="header-anchor" href="#数据库" aria-label="Permalink to &quot;数据库&quot;">​</a></h4><p>为了在重启之后仍能保留数据，我们需要通过某种方法将其存储在数据库中。在普通插件中为 SQL 数据库，可本地也可远程。而在本附属的情况下，数据库必须使用远程类型——这样所有空岛实例都可与其交互。数据库除了必须为远程类型以外，没有任何限制或条件。最理想的数据库是 Redis，它既可以是数据库，也可以是消息代理（上文提及），但所有选择都取决于你。</p><h3 id="多群组" tabindex="-1">多群组 <a class="header-anchor" href="#多群组" aria-label="Permalink to &quot;多群组&quot;">​</a></h3><p>如今，大型网络群组并不能只依赖一个群组（无论 Velocity 或 BungeeCord）来承载所有玩家，因此他们需要多个群组。这使我们面临着一个新的挑战——我们如何在多个群组之间同步所有数据？</p><p>一开始这听起来可能会很吓人，但在了解多群组的搭建后，这其实会非常简单。群组都会连接至同一服务器，因此来自于群组 A 的玩家可以一起与群组 B 的玩家游玩。玩家无法感知这种安装方式，因此也不会注意到什么——因此，剩下的只有了解附属如何与群组交互，以及我们如何安装它。附属需要与群组交流，并做两件事——首先是在服务器间迁移玩家，其次是知晓玩家的新岛屿创建在哪个服务器。</p><h4 id="管理器" tabindex="-1">管理器 <a class="header-anchor" href="#管理器" aria-label="Permalink to &quot;管理器&quot;">​</a></h4><p>在多个群组服中，我们需要一个能够管理所有群组下空岛的第三方服务。管理器会等待空岛实例并与之交流，并在之后自行处理一切。它会记录岛屿所属服务器，并通过岛屿活跃状态自动选择创建新岛屿的最优服务器。</p><p>在玩家创建岛屿时，附属会先向管理器发送请求并选择创建岛屿的最优服务器，而非直接在服务器上创建岛屿。之后，它会检查选中的服务器是否为自己所在服务器——如果是，那么将进行正常的岛屿创建流程，之后便会将玩家传送至新岛屿。</p><p>管理器负责处理如下内容：</p><ul><li>注册新服务器</li><li>（当服务器关闭时）注销服务器</li><li>选择创建岛屿的最优服务器 <ul><li>该过程应当检查活跃数量最少的岛屿。</li></ul></li><li>获取岛屿所在的服务器</li></ul><h2 id="安装教程" tabindex="-1">安装教程 <a class="header-anchor" href="#安装教程" aria-label="Permalink to &quot;安装教程&quot;">​</a></h2><h3 id="第一步-下载-zip-文件。" tabindex="-1">第一步：下载 zip 文件。 <a class="header-anchor" href="#第一步-下载-zip-文件。" aria-label="Permalink to &quot;第一步：下载 zip 文件。&quot;">​</a></h3><p>下载本拓展后，你得到的是一份包含多个文件的压缩包：</p><ul><li><code>SSBProxyBridge-X.Y.Z.jar</code> - 此即为拓展 jar 文件本身。它应当安装在所有子服上。</li><li><code>SSBProxyBridge-Manager-X.Y.Z_standalone.jar</code> - 此为独立管理器 jar 文件。它应当以启动服务器核心的方式使用。</li></ul><h3 id="第二步-初次运行" tabindex="-1">第二步：初次运行 <a class="header-anchor" href="#第二步-初次运行" aria-label="Permalink to &quot;第二步：初次运行&quot;">​</a></h3><p>运行管理器及所有子服实例。这个操作会生成附属的所有配置文件，以及初始化管理器。</p><h3 id="第三步-配置" tabindex="-1">第三步：配置 <a class="header-anchor" href="#第三步-配置" aria-label="Permalink to &quot;第三步：配置&quot;">​</a></h3><h4 id="管理器配置" tabindex="-1">管理器配置 <a class="header-anchor" href="#管理器配置" aria-label="Permalink to &quot;管理器配置&quot;">​</a></h4><p>你可以配置管理器监听的 IP 及端口，以及 <code>keep-alive</code> 间隔和不会生成岛屿的服务器，无需将未安装附属的子服列入该列表。</p><h4 id="附属配置" tabindex="-1">附属配置 <a class="header-anchor" href="#附属配置" aria-label="Permalink to &quot;附属配置&quot;">​</a></h4><p>附属的配置文件比管理器的更复杂。它包含两个需要配置的主要部分：<code>messaging-service</code> 和 <code>manager</code>。这些部分决定了附属于其他子服和管理器的通信方式。在运行服务器之间正确配置这些内容很重要。</p><div class="warning custom-block"><p class="custom-block-title">警告</p><p>在配置 <code>server</code> 不分是，确保填入的 ID 与群组（Velocity 或 BungeeCord）配置下的子服名称相同。</p></div>',60)),r(o),r(i)])}const S=l(h,[["render",s]]);export{q as __pageData,S as default};
